/** 위크맵과 위크셋
 * 자바스크립트 엔진은 도달 가능한 (그리고 추후 사용될 가능성이 있는)값을 메모리에 유지한다
 */
let john = { name: "John" };

// 위 객체는 john이라는 참조를 통해 접근할 수 있다.

// 그런데 참조를 null로 덮어쓰면 위 객체에 더 이상 도달이 가능하지 않게 되어
john = null;

// 객체가 메모리에서 삭제된다.

/* 자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안 대개 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않는다.
   객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 이에 해당한다.

   에를 들어, 배열에 객체 하나를 추가해보자. 이때 배열이 메모리에 남아있는 한, 배열의 요소인 이 객체도 메모리에 남아있게 된다. */

john = { name: "John" };

let array = [john];

john = null; // 참조를 null로 덮어씀

// john을 나타내는 객체는 배열의 요소이기 때문에 가비지 컬렉터의 대상이 되지 않는다.
// array[0]을 이용하면 해당 객체를 얻는 것도 가능하다.
alert(JSON.stringify(array[0]));

/* 맵에서 객체로 키를 사용한 경우, 맵이 메모리에 있는 한 객체도 메모리에 남는다. */
john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null;

// john을 나타내는 객체는 맵 안에 저장되어있다.
// map.keys()를 이용하면 해당 객체를 얻는 것도 가능하다.
for (let obj of map.keys()) {
    alert(JSON.stringify(obj));
}

alert(map.size);

/* 이런 관점에서 위크맵(WeakMap)은 일반 맵과 전혀 다른 양상을 보인다. 
   위크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉터의 대상이 된다. */

///////////////////////////////////////////////

/** 위크맵
 * 맵과 위크맵의 첫 번째 차이는 위크맵의 키가 반드시 객체여야한다는 점이다.
 * 원시값은 위크맵의 키가 될 수 없다.
 */
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // 정상적으로 동작한다(객체 키).

// 문자열("test")은 키로 사용할 수 없다.
weakMap.set("test", "Whoops"); // Error: Invalid value used as weak map key
/* 위크맵의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 객체는 메모리와 위크맵에서 자동으로 삭제된다. */

john = { name: "John" };

weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // 참조를 덮어씀

// john을 나타내는 객체는 이제 메모리에서 지워진다!

/* john을 나타내는 객체는 오로지 위크맵의 키로만 사용되고 있으므로, 참조를 덮어쓰게 되면 이 객체는 위크맵과 메모리에서 자동으로 삭제된다.
   
   맵과 위크맵의 두 번째 차이는 위크맵은 반복 작업과 keys(), values(), entries() 메서드를 지원하지 않는다는 점이다.
   따라서 위크맵에선 키나 값 전체를 얻는 게 불가능하다.

   위크맵이 지원하는 메서드는 단출하다.
    * weakMap.get(key)
    * weakMap.set(key, value)
    * weakMap.delete(key)
    * weakMap.has(key)
   왜 이렇게 적은 메서드만 제공할까? 원인은 가비지 컬렉션의 동작 방식 때문이다.
   위 예시 객체처럼, 객체는 모든 참조를 잃게 되면 자동으로 가비지 컬렉션의 대상이 된다.
   그런데 가비지 컬렉션의 동작 시점은 정확히 알 수 없다.

   가비지 컬렉션이 일어나는 시점은 자바스크립트 엔진이 결정한다. 
   객체는 모든 참조를 잃었을 때, 그 즉시 메모리에서 삭제될 수 있고, 다른 삭제 작업이 있을 때까지 대기하다가 함께 삭제될 수도 있다.
   현재 위크맵에 요소가 몇 개 있는지 정확히 파악하는 것 자체가 불가능한 것이다.
   가비지 컬렉터가 한 번에 메모리를 청소할 수도 있고, 부분 부분 메모리를 청소할 수도 있으므로 
   위크맵의 요소(키/값)전체 대상으로 무언가를 하는 메서드는 동작 자체가 불가능하다.

   그럼 위크맵은 어떤 경우에 사용할 수 있을까? */

/** 유스 케이스: 추가 데이터
 * 위크맵은 부차적인 데이터를 저장할 곳이 필요할 때 그 진가를 발휘한다.
 * 
 * 서드파티 라이브러리와 같은 외부 코드에 '속한' 객체를 가지고 작업을 해야한다고 가정해보자.
 * 이 객체에 데이터를 추가해줘야 하는데, 추가해줄 데이터는 객체가 살아있는 동안에만 유효한 상황이다.
 * 이럴 때 위크맵을 사용할 수 있다.
 * 
 * 위크맵에 원하는 데이터를 저장하고, 이때 키는 객체를 사용하면 된다. 이렇게 하면 객체가 가비지 컬렉션의 대상이 될 때, 데이터도 함께 사라지게 된다.
 * 
 weakMap.set(john, "비밀문서");
 // john이 사망하면, 비밀문서는 자동으로 파기된다. 
 * 
 * 좀더 구체적인 예시를 들어보자
 * 아래에 사용자의 방문 횟수를 세어 주는 코드가 있다. 
 * 관련 정보는 맵에 저장하고 있는데 맵 요소의 키엔 특정 사용자를 나타내는 객체를, 값엔 해당 사용자의 방문 횟수를 저장하고 있다.
 * 어떤 사용자의 정보를 저장할 필요가 없어지면(가비지 컬렉션의 대상이 되면) 해당 사용자의 방문 횟수도 저장할 필요가 없어질 거다.
 */

// 아래 함수는 맵을 사용해 사용자의 방문 횟수를 세준다.
// visitsCount.js
let visitsCountMap = new Map(); // 맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려준다.
function countUser(user) {
    let count = visitsCountMap.get(user) || 0;
    visitsCountMap.set(user, count + 1);
}

// 아래는 John이라는 사용자가 방문했을 때, 어떻게 방문 횟수가 증가하는지를 보여준다.
// main.js
john = { name: "John" };

countUser(john); // John의 방문 횟수를 증가시킨다.

// John의 방문 횟수를 셀 필요가 없어지면 아래와 같이 john을 null로 덮어 쓴다.
john = null;

/* 이제 john을 나타내는 객체는 가비지 컬렉션의 대상이 되어야 하는데, 
   visitsCountMap의 키로 사용되고 있어서 메모리에서 삭제되지 않는다.

   특정 사용자를 나타내는 객체가 메모리에서 사라지면 해당 객체에 대한 정보(방문 횟수)도 우리가 순수 지워야하는 상황이다.
   이렇게 하지 않으면 visitsCountMap가 차지하는 메모리 공간이 한없이 커질 것이다.
   애플리케이션 구조가 복잡할 땐, 이렇게 쓸모 없는 데이터를 수동으로 비워주는 게 꽤 골치 아프다.

   이런 문제는 위크맵을 사용해 에방할 수 있다.
*/
// visitsCount.js
let visitsCountWeakMap = new WeakMap(); // 위크맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려준다.
function countUser(user) {
    let count = visitsCountWeakMap.get(user) || 0;
    visitsCountWeakMap.set(user, count + 1);
}

/* 위크맵을 사용해 사용자 방문 횟수를 저장하면 visitsCountWeakMap을 수동으로 청소해줄 필요가 없다.
   john을 나타내는 객체가 도달 가능하지 않는 상태가 되면 자동으로 메모리에서 삭제되기 때문이다. 
   위크맵의 키(john)에 대응하는 값(john의 방문횟수)도 자동으로 가비지 컬렉션의 대상이 된다.
*/
